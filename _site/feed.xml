<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://codemath.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.2.1">Jekyll</generator><link href="https://codemath.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://codemath.github.io/" rel="alternate" type="text/html" /><updated>2017-09-09T08:11:27+09:00</updated><id>https://codemath.github.io/</id><title type="html">coDematH</title><subtitle>The goal is not to find a job, but to CREATE one for myself.</subtitle><entry><title type="html">Selenium 활용기(1)</title><link href="https://codemath.github.io/Selenium-%ED%99%9C%EC%9A%A9%EA%B8%B0(1)/" rel="alternate" type="text/html" title="Selenium 활용기(1)" /><published>2017-09-08T00:00:00+09:00</published><updated>2017-09-08T00:00:00+09:00</updated><id>https://codemath.github.io/Selenium 활용기(1)</id><content type="html" xml:base="https://codemath.github.io/Selenium-%ED%99%9C%EC%9A%A9%EA%B8%B0(1)/">&lt;figure&gt;
	&lt;img src=&quot;https://huddle.eurostarsoftwaretesting.com/wp-content/uploads/2017/02/Selenium.jpg&quot; /&gt;
&lt;/figure&gt;

&lt;hr /&gt;

&lt;p&gt;그동안 Beautifulsoup를 이용한 크롤링을 자주 하다, 몇몇 멋진(?) 사이트들은 단순히 이전에 사용했던 라이브러리를 이용해 크롤링이 되지 않는 다는 것을 발견하였다.(우리나라 뿐 만 아니라, 몇몇 멋진 사이트들이 그러하다…. 자바스크립트로 데이터를 넣는 경우 또는 iframe 인 경우)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.fcsc.kr/D/fu_d_08_04.jsp&quot;&gt;e-금융민원센터&lt;/a&gt; 페이지를 열어서 Beautifulsoup를 사용하려 하였다.
페이지를 열어보면 역시나 iframe으로 데이터 테이블이 구성되어있다. 따라서 해당 테이블의 데이터를 뽑기 위해서는 직접 iframe 주소를 열어서 확인하는 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;우선 해당 iframe 주소를 Beautifulsoup를 이용해 열어보니, 구조는 그렇게 복잡하지 않았다. 하지만 Pagination으로 구성된 코드를 보면 다음과 같았다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;Lcenter&quot;&amp;gt;
	&amp;lt;a href=&quot;#first&quot; onclick=&quot;alert('첫페이지 입니다.');&quot;&amp;gt;&amp;lt;img alt=&quot;처음페이지로 이동&quot; src=&quot;/kr/integration/img/theme01/paging_first.gif&quot;/&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a href=&quot;#prev&quot; onclick=&quot;alert('이전페이지 세트가 없습니다.');&quot;&amp;gt;&amp;lt;img alt=&quot;이전 페이지세트로 이동&quot; src=&quot;/kr/integration/img/theme01/paging_before.gif&quot;/&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a href=&quot;#paging&quot; onclick=&quot;paging('1'); return false;&quot;&amp;gt;&amp;lt;span class=&quot;first Lcurrent&quot;&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a href=&quot;#paging&quot; onclick=&quot;paging('2'); return false;&quot;&amp;gt;&amp;lt;span&amp;gt;2&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a href=&quot;#paging&quot; onclick=&quot;paging('3'); return false;&quot;&amp;gt;&amp;lt;span&amp;gt;3&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a href=&quot;#paging&quot; onclick=&quot;paging('4'); return false;&quot;&amp;gt;&amp;lt;span&amp;gt;4&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a href=&quot;#paging&quot; onclick=&quot;paging('5'); return false;&quot;&amp;gt;&amp;lt;span&amp;gt;5&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a href=&quot;#paging&quot; onclick=&quot;paging('6'); return false;&quot;&amp;gt;&amp;lt;span&amp;gt;6&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a href=&quot;#paging&quot; onclick=&quot;paging('7'); return false;&quot;&amp;gt;&amp;lt;span&amp;gt;7&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a href=&quot;#paging&quot; onclick=&quot;paging('8'); return false;&quot;&amp;gt;&amp;lt;span&amp;gt;8&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a href=&quot;#paging&quot; onclick=&quot;paging('9'); return false;&quot;&amp;gt;&amp;lt;span&amp;gt;9&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a href=&quot;#paging&quot; onclick=&quot;paging('10'); return false;&quot;&amp;gt;&amp;lt;span&amp;gt;10&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a class=&quot;next&quot; href=&quot;#next&quot; onclick=&quot;paging('11'); return false;&quot;&amp;gt;&amp;lt;img alt=&quot;다음 페이지세트로 이동&quot; src=&quot;/kr/integration/img/theme01/paging_next.gif&quot;/&amp;gt;&amp;lt;/a&amp;gt;
	&amp;lt;a href=&quot;#last&quot; onclick=&quot;paging('152'); return false;&quot;&amp;gt;&amp;lt;img alt=&quot;마지막 페이지로 이동&quot; src=&quot;/kr/integration/img/theme01/paging_last.gif&quot;/&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Pagination 코드 부분이 onclick 이벤트로 함수를 불러서 이동하는 것이다. 그리고 10개 단위로 ‘다음 페이지 세트’로 이동도 해줘야한다. 이럴 경우 단순한 HTML 코드로 전체 데이터를 긁어오는 것이 무리다. 따라서 Beautifulsoup가 아닌 Selenium을 이용해 데이터를 긁어오도록 하였다.&lt;/p&gt;

&lt;h2 id=&quot;selenium-코드-python27-기준&quot;&gt;Selenium 코드 (Python2.7 기준)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: utf-8 -*-
import urllib2
from selenium import webdriver
from selenium.webdriver.support.ui import Select
import csv

hdr = {'User-Agent': 'Mozilla/5.0', 'referer': 'http://www.google.com'}
path = &quot;/PATH-TO-/chromedriver&quot;
urls = &quot;http://61.73.100.30/kr/bbs/iframe/list.jsp?bbsid=1273209703694&quot;

# csv open
f = open('output.csv', 'w')
wr = csv.writer(f)
wr.writerow([u'#',u'상호'.encode('utf-8'),u'홈페이지'.encode('utf-8'),u'대표자'.encode('utf-8'),u'모바일'.encode('utf-8')])

driver = webdriver.Chrome(path)
driver.get(urls)

a_link = 3
for each in range(1,153):
    if each != 152:
        sections = range(1,11)
    else:
        sections = range(1,5)
    for li in sections:
        ids = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[1]').text
        title = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[2]').text
        webs = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[3]').text
        name = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[4]').text
        mobile = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[5]').text
        wr.writerow([ids.encode('utf-8'),title.encode('utf-8'),webs.encode('utf-8'),name.encode('utf-8'),mobile.encode('utf-8')])

    if a_link == 13:
        a_link = 4

    else:
        a_link += 1        
    
    on_html_bt = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[3]/div/a[%s]' %(a_link))
    on_html_bt.click()
    
print &quot;-----fin-----&quot;

f.close()

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;우선 전체적인 코드는 위와 같다. 하나씩 뜯어서 분석해보자.&lt;/p&gt;

&lt;h2 id=&quot;1-import-라이브러리&quot;&gt;1) import 라이브러리&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: utf-8 -*-
import urllib2
from selenium import webdriver
from selenium.webdriver.support.ui import Select
import csv
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;기본적으로 selenium을 통해 자동으로 웹 사이트에 들어가는 것이므로 urllib2 모듈과 selenium을 불러온다.
편하게 설치하기 위해서는 pip 로 설치하는게 좋다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;pip install selenium&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://selenium-python.readthedocs.io/installation.html&quot;&gt;설치 DOC&lt;/a&gt;
로 설치하자. 그리고 추가적으로 설치해야하는 드라이버가 있는데, 개인의 취향(?)에 따른 드라이버를 다운받는다.
webdriver를 통해 우리가 사용하는 노트북,컴퓨터의 브라우저를 자동 제어할 수 있기 위함이다.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;https://github.com/CodeMath/codemath.github.io/blob/master/assets/img/media/selenium_0.png?raw=true&quot; /&gt;
&lt;/figure&gt;
&lt;p&gt;webdriver 폴더에 들어가면 다양한 브라우저를 지원하는 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;보통 윈도우/맥 유저 편하게 사용할 수 있는 크롬 브라우저 웹 드라이버를 다운받자.(아니면 파이어폭스)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sites.google.com/a/chromium.org/chromedriver/downloads&quot;&gt;Chrome driver 다운로드 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mozilla/geckodriver&quot;&gt;FireFox driver 다운로드 링크&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-접속할-url-setting&quot;&gt;2) 접속할 URL setting&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hdr = {'User-Agent': 'Mozilla/5.0', 'referer': 'http://www.google.com'}
path = &quot;/PATH-TO-/chromedriver&quot;
urls = &quot;http://61.73.100.30/kr/bbs/iframe/list.jsp?bbsid=1273209703694&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;figure&gt;
	&lt;img src=&quot;https://github.com/CodeMath/codemath.github.io/blob/master/assets/img/media/crawling_website.png?raw=true&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;헤더 정보에 ‘User-Agent’ 부분에 ‘Mozilla/5.0’로 입력하고 ‘referer’에는 그냥 ‘http://www.google.com’ 입력하자.&lt;/p&gt;

&lt;p&gt;사실 ‘User-Agent’는 쉽게 말해 브라우저의 종류를 판단하는 것으로 사용되어왔다.(물론 워낙 브라우저 종류가 많아서, 판단하기가 쉽지는 않지만.) 대표적인 브라우저 몇몇의 특징이 있다. 그동안 브라우저나 OS 판단 용으로 이해하고 있었는데 이번 기회에 확실하게 공부하였다.&lt;/p&gt;

&lt;p&gt;자세한 내용은 다음 사이트를 참고하면 된다.(물론 크롤링하기 위해서 다 알아야할 필요는 없지만…) 
&lt;a href=&quot;http://ohgyun.com/292&quot;&gt;User-Agent 설명 잘 된 사이트 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;또한 ‘referer’는 로그분석이나 접근제어할 때 주로 사용한다. 쉽게 말해 어디에서 이 사이트로 들어왔나? 라는 정보를 가지고 온다고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;그리고 urls 변수에 크롤링할 URL을 입력한다.&lt;/p&gt;

&lt;h2 id=&quot;3-접속할-url-setting&quot;&gt;3) 접속할 URL setting&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# csv open
f = open('output.csv', 'w')
wr = csv.writer(f)
wr.writerow([u'#',u'상호'.encode('utf-8'),u'홈페이지'.encode('utf-8'),u'대표자'.encode('utf-8'),u'모바일'.encode('utf-8')])

driver = webdriver.Chrome(path)
driver.get(urls)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;우리가 뽑을 데이터를 단순히 print 하기에는 아까우니(?) CSV 형태로 뽑아서 정리하자. python에는 기본적으로 csv로 뽑을 수 있는 모듈이 있으므로 별도 설치할 필요없이 바로 불러온다.&lt;/p&gt;

&lt;p&gt;새로운 csv 파일을 만들기 위해서는 주석을 제외한 첫 번째 코드를 보면 된다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;f = open(‘output.csv’, ‘w’)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기서 open함수에는 읽기/쓰기/수정 등등의 권한을 명시하여 사용하면 된다. 우리는 쓰기 권한이 필요하므로 ‘w’ = ‘write’.&lt;/p&gt;

&lt;p&gt;csv부분에 대한 자세한 공부는 &lt;a href=&quot;https://docs.python.org/2/library/csv.html&quot;&gt;다음 링크&lt;/a&gt;를 참조하자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;wr = csv.writer(f)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 코드는 앞서 열었던 csv 파일(f)에 작성을 한다는 뜻이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;wr.writerow([u’#’,u’상호’.encode(‘utf-8’),u’홈페이지’.encode(‘utf-8’),u’대표자’.encode(‘utf-8’),u’모바일’.encode(‘utf-8’)])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그리고 첫 번째 row에는 table에서 뽑을 데이터 구분을 위해 미리 1줄을 입력하자. ‘writerow’를 통해 한 줄을 작성한다.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;https://designedbynatalie.files.wordpress.com/2011/05/asciierrorsgraphic.gif?raw=true&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;그런데 python2.7 버전에서는 한글을 쓰면 아스키 에러를 토해낸다.(그러게 python 3으로 넘어갔어야지…ㅠㅠ)
급하게 코드를 만들어야 했기 때문에 어쩔 수 없이 각 한글에 .encode(‘utf-8’) 을 붙여주자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;driver = webdriver.Chrome(path)
driver.get(urls)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;그리고 앞서 설정한 크롬 브라우저 드라이버의 경로값을 넣어서 webdriver를 불러오자. 크롤링할 웹 사이트로 이동하자.(get method)&lt;/p&gt;

&lt;h2 id=&quot;4-javascript-잡아내기&quot;&gt;4) Javascript 잡아내기&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a_link = 3
for each in range(1,153):
    if each != 152:
        sections = range(1,11)
    else:
        sections = range(1,5)
    for li in sections:
        ids = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[1]').text
        title = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[2]').text
        webs = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[3]').text
        name = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[4]').text
        mobile = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[5]').text
        wr.writerow([ids.encode('utf-8'),title.encode('utf-8'),webs.encode('utf-8'),name.encode('utf-8'),mobile.encode('utf-8')])

    if a_link == 13:
        a_link = 4

    else:
        a_link += 1        
    
    on_html_bt = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[3]/div/a[%s]' %(a_link))
    on_html_bt.click()
    
print &quot;-----fin-----&quot;

f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;우선 전체 크롤링할 페이지가 152페이지인 것을 알 고 있으니, range(1,153)으로 설정하자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    
    if each != 152:
        sections = range(1,11)
    else:
        sections = range(1,5)
    for li in sections:
    	...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;그리고 마지막 페이지에서 크롤링할 데이터가 4개 이므로 152일 때 range(1,5)로 설정했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for li in sections:
	ids = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[1]').text
	title = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[2]').text
	webs = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[3]').text
	name = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[4]').text
	mobile = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[5]').text
	wr.writerow([ids.encode('utf-8'),title.encode('utf-8'),webs.encode('utf-8'),name.encode('utf-8'),mobile.encode('utf-8')])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;이제 sections 기준으로 for loop를 돌리면 된다. 여기서 selenium flow를 설명을 하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;driver = webdriver.Chrome(path) # 크롬 드라이버 실행(자동 제어)
driver.get(urls) # url 이동(get)
driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[2]/table/tbody/tr['+str(li)+']/td[1]').text # 이동 페이지에서 element를 찾는다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이동할 페이지에서 element를 찾을 때 id 값이나 class나 다양한 방법으로 처리할 수 있지만, 가장 편한 방법은 xpath로 찾는 것이다. (편함 x 1000000)&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;https://github.com/CodeMath/codemath.github.io/blob/master/assets/img/media/selenium_1.png?raw=true&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;크롬 브라우저 기준으로 크롤링할 데이터가 있는 부분에 마우스 우클릭-&amp;gt;검사-&amp;gt;Copy-&amp;gt;Copy XPath 로 가져오면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;’//*[@id=”content”]/div[2]/table/tbody/tr[‘+str(li)+’]/td[1]’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞서 가져온 XPath를 분석해보면 id값 기준으로 트리를 타는 듯 한 느낌이 보인다. (‘/’ 기준으로 트리로 자식안으로 쉽게 들어가니까…)&lt;/p&gt;

&lt;p&gt;여튼 다시 본론으로 들어가면, 각 페이지마다 10개의 데이터가 있다. 따라서 loop를 돌릴 때, 각각의 데이터들에 맞게 위치를 맞춰서 돌리면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;wr.writerow([ids.encode(‘utf-8’),title.encode(‘utf-8’),webs.encode(‘utf-8’),name.encode(‘utf-8’),mobile.encode(‘utf-8’)])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그리고 뽑은 데이터를 앞서 만든 csv에 1개 row로 넣는다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if a_link == 13:
	a_link = 4

else:
	a_link += 1        
    
on_html_bt = driver.find_element_by_xpath('//*[@id=&quot;content&quot;]/div[3]/div/a[%s]' %(a_link))
on_html_bt.click()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;앞서 Pagination 부분을 보면 onclick event로 넘어가는 것을 확인했다. 따라서 다음 페이지로 이동할 때를 생각하면 다음과 같은 로직으로 정리된다. 처음에는 1페이지이지만, XPath 는&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;’//*[@id=”content”]/div[3]/div/a[3]’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 3번째 a 테그 부터가 1,11,21,31… 로 시작하는 것이다. 따라서 맨 처음 시작을 a_link라는 변수에 3으로 담아서 시작한다.&lt;/p&gt;

&lt;p&gt;첫 번째 페이지에서 데이터를 뽑으면 a_link는 3이지 13이 아니므로, +=1이 되어 4가 되고 2번째 페이지로 이동한다.
이 과정이 계속 일어나면 10번째 페이지로 이동할 때는 a_link는 12이 된다. 10번 째 페이지의 데이터를 뽑고 나서 a_link는 12이므로 역시 +=1이되어 13이 되고 13번째 a 테그가 있는 부분인 ‘다음 페이지 세트’로 넘어가게 된다.
(이제 페이지 세트가 바뀌게되었다. 1,2,3,4.. -&amp;gt; 11,12,13,14…)페이지를 이동하면 바로 11페이지로 이동하므로 해당 데이터를 뽑는다.&lt;/p&gt;

&lt;p&gt;그리고 앞서 a_link는 13이라고 했으므로 11페이지에서 12페이지로 이동해야한다. 따라서 a_link를 4로 다시 할당한다.
이러한 과정이 1페이지 부터 152페이지까지 계속 도는 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print &quot;-----fin-----&quot;

f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;마지막으로 앞서 열었던 csv파일인 f를 닫아준다. (print 는 끝났다는 신호로 사용)&lt;/p&gt;

&lt;p&gt;최종 정리된 데이터가 들어있는 csv파일을 열어보면 이쁘게 정리되어있는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;해당 프로젝트 다운로드 링크 : &lt;a href=&quot;&amp;quot;https://github.com/CodeMath/codemath.github.io/blob/master/assets/img/media/selenium_crawling_table.ipynb&amp;quot;&quot;&gt;Jupyter notebook&lt;/a&gt;&lt;/p&gt;</content><category term="python" /><category term="크롤링" /><category term="Selenium" /><category term="프로젝트" /><category term="데이터 크롤링" /><summary type="html">Selenium 활용기(1)-크롤링(부제:정부기관 사이트는 정말...)</summary></entry><entry><title type="html">2017.07 coDematH 개발 로드맵(2개월 점검)</title><link href="https://codemath.github.io/2017.07-coDematH-%EA%B0%9C%EB%B0%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5(2)/" rel="alternate" type="text/html" title="2017.07 coDematH 개발 로드맵(2개월 점검)" /><published>2017-07-20T00:00:00+09:00</published><updated>2017-07-20T00:00:00+09:00</updated><id>https://codemath.github.io/2017.07-coDematH-개발-로드맵(2)</id><content type="html" xml:base="https://codemath.github.io/2017.07-coDematH-%EA%B0%9C%EB%B0%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5(2)/">&lt;figure&gt;
	&lt;img src=&quot;https://github.com/CodeMath/codemath.github.io/blob/master/assets/img/media/2017.05-LoadMap.png?raw=true&quot; /&gt;
&lt;/figure&gt;

&lt;hr /&gt;

&lt;p&gt;지난 번 작성한 포스트에 이어서 글을 남겨봅니다.&lt;/p&gt;

&lt;h3 id=&quot;웹-프로그래밍&quot;&gt;웹 프로그래밍&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Django를 기반으로 Nginx와 uwsgi 구조에 대해 더욱 공부해야겠다.&lt;/li&gt;
  &lt;li&gt;TDD에 대해 공부해야겠다.(몇 차례 시작하려 했지만…)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ios-프로그래밍&quot;&gt;iOS 프로그래밍&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Swift와 iOS 프로그래밍 구조에 대해 심도있게 공부해야겠다.(현재는 너무 얕은 느낌이 강하다.)&lt;/li&gt;
  &lt;li&gt;오픈소스 라이브러리를 만들어보고싶다.(희망고문일까?)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dev-ops&quot;&gt;Dev-Ops&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Docker 책 샀지만 많이 보지 않았다. 제대로 다시 공부하자.&lt;/li&gt;
  &lt;li&gt;Github와 연계된 다양한 서비스들(Travis 등등)을 사용해보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;앞으로 공부하고 싶은 부분에 대해서 지난번 시간에 정리를 했었습니다. 벌써 2개월이 지난 지금 얼마나 지켜졌을까요?&lt;/p&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;웹-프로그래밍-1&quot;&gt;웹 프로그래밍&lt;/h5&gt;

&lt;p&gt;Django 관련해서 기초부터 다시 공부를 시작하였습니다. 공식 문서를 차근차근 읽어보고 다른 사람들이 만들었던 자료들(Django 개발)을 하나씩 읽고 정리하는 시간을 가졌습니다. Django Girls 문서를 참조하면서 차근차근 제 나름대로 문서를 만들어 정리를 했습니다. (물론 코드상으로는 동일하지만 내용적으로 추가할 내용과 나름대로 변경하여 작성했죠…) Nginx와 uwsgi를 공부하려다가 기본부터 차근차근! 이라는 생각으로 시작했습니다. 물론 이 덕분에 외부 강의에서 ‘친절’하게 궁금증을 해결해줘서 고맙다는 말을 듣기도 했었습니다.&lt;/p&gt;

&lt;p&gt;하지만 여전히 TDD는 공부하지 못했습니다. 대신 python 에 대해서 조금 더 깊게 공부하기 시작했습니다. python 내장함수와 내장 라이브러리들을 하나씩 뜯어 보면서 어떤 것들이 있는지 공부를 했었습니다.(reddit에 올라온 python 관련 글들을 보면서…) 그리고 지금 나에게 필요한 것이 디자인 페턴이라는 것도 알게 되었습니다. 책장에 디자인 페턴 관련 책이 있긴 있었지만, 살짝 보고 말았던 터라 다시 그 책을 보기 시작했습니다.&lt;/p&gt;

&lt;p&gt;우선 위 과정을 먼저 하고서, 서버와 통신 쪽 공부를 다시 시작해야겠습니다. (아무래도 기초공사가 부실하면 안되니까…) 관련성이 거의 없기도 하지만, python을 사랑하기 때문에 이 쪽이 더 먼저 강하게 다가왔습니다.&lt;/p&gt;

&lt;h5 id=&quot;ios-프로그래밍-1&quot;&gt;iOS 프로그래밍&lt;/h5&gt;

&lt;p&gt;iOS 프로그래밍 관련해서 여러 자료들을 읽었고, 개발 관련해서 다른 사람들이 어떤 식으로 구조를 짰는지에 대해 집중적으로 보았습니다. 많은 시간이 필요했지만, 핵심적인 부분 부터 차근차근 정리하였고 어떤 방식으로 개발시간을 단축(UI 재사용)했는지가 가장 궁금했기에 그 부분에 대해서 자료들을 많이 찾아봤습니다. 새로운 버전으로 현재 하고 있는 프로젝트가 업데이트 되기 때문에 AWS Lambda를 이용해서 serverless API를 현재 개발중이라 많은 시간을 할애하지 못했지만 조금씩 공부를 하고 있습니다.&lt;/p&gt;

&lt;h5 id=&quot;dev-ops-1&quot;&gt;Dev-Ops&lt;/h5&gt;

&lt;p&gt;우선 Docker를 공부하지 못했습니다. 워낙 프로젝트 일정이 빡빡해서… 아무래도 python 공부가 우선시 되다보니… 이 부분은 아직 시작도 못한 것 같습니다. 생각보다 공부할 것도 많고 프로젝트 진행도 해야하고 정신이 없다보니 이렇게 된 것 같습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;전반적으로 많은 시간을 투자하지 못했습니다. 2개월 동안 뭘 했는지 생각해봤지만, 막상 떠오르는 부분이 별로 없습니다. 가끔은 개발을 하는게 적성에 맞나? 싶을 정도로 고민을 한 적도 있습니다. 전 세계에는 정말 우수한 개발자들이 많습니다. 그 중 1명이 되고 싶다는 욕심은 있지만 아직까지 부족한게 너무 많다고 생각됩니다. 만약 스타트업을 먼저 시작한게 아니라, 특정 기업에 들어가서 개발을 시작했다면 지름길로 갈 수 있지않았을까? 라는 생각도 합니다. 그렇다고 무조건 취업을 해서 개발을 하려는 것은 아닙니다. 내가 하고 싶은 개발 공부와 방향에 대해 스스로 생각하고 나아갈 수 있다는 것이 얼마나 행복하고 즐거운 지 모릅니다. 무엇보다 다양한 프로젝트를 하면서 기존에 사용했던 방식이 아닌, 새로운 방식을 계속 도입하면서 어딘지 모를 곳에 마음껏 도약할 수 있습니다. 그렇기 때문에 내 동기 및 친구들과는 다른 길을 걸으며 느리게 그리고 조금 돌아서 앞으로 가고 싶습니다.&lt;/p&gt;

&lt;p&gt;2개월 뒤 또 만날 수 있기를 바라며…&lt;/p&gt;</content><category term="post" /><category term="develop" /><category term="로드맵" /><category term="정리" /><category term="개발" /><summary type="html">2017년 7월 기준 로드맵 정리</summary></entry><entry><title type="html">[Python-Flask WEB SSE]-1</title><link href="https://codemath.github.io/Python-Flask-WEB-SSE-1/" rel="alternate" type="text/html" title="[Python-Flask WEB SSE]-1" /><published>2017-07-18T00:00:00+09:00</published><updated>2017-07-18T00:00:00+09:00</updated><id>https://codemath.github.io/[Python-Flask WEB SSE]-1</id><content type="html" xml:base="https://codemath.github.io/Python-Flask-WEB-SSE-1/">&lt;p&gt;전반적인 프로젝트 flow는 다음과 같다.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;https://github.com/CodeMath/codemath.github.io/blob/master/assets/img/media/SSE_and_openCV.png?raw=true&quot; /&gt;
&lt;/figure&gt;

&lt;hr /&gt;

&lt;p&gt;이번 프로젝트에서는 openCV를 이용해서 QR code 좌표값을 읽어서 웹에서 보여주는 것을 해보았다.&lt;/p&gt;

&lt;p&gt;먼저 opencv를 이용해서 QR code를 읽어서 중심좌표를 구하는 것을 만들어 보았다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/zplab/zbar-py
위 github 에서 코드를 이용하였다.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;qr-code-인식방법&quot;&gt;QR-Code 인식방법&lt;/h3&gt;

&lt;p&gt;(1) 이미지 프로세싱&lt;/p&gt;

&lt;p&gt;QR-code 이미지 자체를 별도로 저장하여 opencv로 해당 이미지를 읽어서 웹캠으로 해당 이미지를 보여줄 때 트래킹이 되게끔하는 것이다. 
위 방법으로 먼저 테스트 빌드를 해보니, 상당히 느렸다. 일단 웹캠에서 각각 화면 마다 위에서 읽은 이미지를 보여질 경우 거리에 비례하여 트래킹하는 것이다. 즉, QR-code 이미지의 사이즈가 가깝거나 멀어져도 동일하기 인식하는 것이다. (물론 웹캠의 능력과 노트북 CPU 한계 때문에 그 성능은….)&lt;/p&gt;

&lt;p&gt;여튼 위 방법으로 하다보니, 이미지 인식자체는 정확하지만 상당히 느리게 작동하여 다른 방법을 생각해봐야했다.&lt;/p&gt;

&lt;p&gt;(2) QR-code와 같은 바코드 형식을 읽자&lt;/p&gt;

&lt;p&gt;위 방법과 조금 다르게 바코드(QR-code 포함)를 자체 인식하는 것으로 해보았다. zbar 라이브러리를 이용해서 QR-code나 바코드 형식이기만 하면, 해당 코드의 정보와 위치값을 뽑을 수 있었다. 아마도 for 문을 이용해서 해당 정보나 위치값을 뽑는 것을 보면 멀티값이 적용 되는 듯.&lt;/p&gt;

&lt;h3 id=&quot;redis-연동&quot;&gt;Redis 연동&lt;/h3&gt;

&lt;p&gt;(1) Redis로 구독채널을 연결하여 데이터를 SSE로 하기 위해서는, Redis에 연결해야했다. 따라서 매 인식마다 request로 업데이트를 하는 방식을 사용했다. redis에 publish를 이용해서 해당 데이터를 json형식으로 저장했다. (이미 보낼 때 json 이다.)&lt;/p&gt;

&lt;p&gt;(2) redis에서 저장한 데이터를 SSE를 이용해서 불러오기(Stream).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
def event_stream():
	pubsub = db.pubsub()
	pubsub.subscribe('stream')
	for msg in pubsub.listen():
		yield u&quot;data: %s\n\n&quot; %msg[&quot;data&quot;]


@app.route('/stream')
def stream():
	return Response(event_stream(), mimetype=&quot;text/event-stream&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;sse-연동&quot;&gt;SSE 연동&lt;/h3&gt;

&lt;p&gt;SSE에서 해당 주소값에 해당하는 EventSource로 접근한다. 그리고 addEventListener로 ‘message’로 데이터를 받아온다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
var source = new EventSource('/stream')
source.addEventListener('message', function(e){
	console.log(e.data);
});


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;이런식으로 연결하면 된다.&lt;/p&gt;</content><category term="python" /><category term="opencv" /><category term="sse" /><category term="web" /><category term="post" /><summary type="html">Flask를 이용한 SSE &amp; openCV로 데이터 전송하기</summary></entry><entry><title type="html">iOS 주파고 런칭까지(1)</title><link href="https://codemath.github.io/iOS-%EC%A3%BC%ED%8C%8C%EA%B3%A0-%EB%9F%B0%EC%B9%AD%EA%B9%8C%EC%A7%80(1)/" rel="alternate" type="text/html" title="iOS 주파고 런칭까지(1)" /><published>2017-06-01T00:00:00+09:00</published><updated>2017-06-01T00:00:00+09:00</updated><id>https://codemath.github.io/iOS-주파고-런칭까지(1)</id><content type="html" xml:base="https://codemath.github.io/iOS-%EC%A3%BC%ED%8C%8C%EA%B3%A0-%EB%9F%B0%EC%B9%AD%EA%B9%8C%EC%A7%80(1)/">&lt;figure&gt;
	&lt;img src=&quot;https://lh3.googleusercontent.com/QWGWN6sKgke9ddo14iPicAiTMvVDGtkQXukdorIf7ovnQhI03JG8NGQTADggJK77pfFh=w300&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.wowwell.stock&quot;&gt;&lt;img src=&quot;https://storage.googleapis.com/support-kms-prod/D90D94331E54D2005CC8CEE352FF98ECF639&quot; alt=&quot;GooglePlay&quot; class=&quot;img-alignleft&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://itunes.apple.com/us/app/주파고/id1229991325&quot;&gt;&lt;img src=&quot;https://www.lawabidingbiker.com/wp-content/uploads/2014/06/logo-app_store.png&quot; alt=&quot;Appstore&quot; class=&quot;img-alignleft&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;iOS 앱을 처음 만들어보았고, Swift 3.0 과 cocoapod을 이용해서 만들었습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;처음-시작&quot;&gt;처음 시작&lt;/h2&gt;

&lt;p&gt;iOS 앱 개발이 처음이었다. 그동안은 웹과 서버를 개발하였는데, 이번 기회에 아이폰 앱 개발을 시작해보았다. 처음 웹을 공부할 때 처럼 쉽지는 않았다. 처음에는 이해하지 못할 코드와 재사용성… 등등 처음에는 정말 힘들었다. 우선 Swift 언어를 기본적으로 공부하면서 xcode에 친숙해지도록 노력하였다. 언어만 안다고 해서 앱을 만들 수 있는게 아니었으니까.&lt;/p&gt;

&lt;p&gt;영문으로 된 서적과 유투브를 보면서 공부하였지만, 생각보다 쉽지 않았다. 설명해주는 부분에서 좀 이해가 힘들어서 결국 한글로 된 개발 서적을 구입!&lt;/p&gt;

&lt;figure class=&quot;half&quot;&gt;
	&lt;img src=&quot;http://gdimg.gmarket.co.kr/goods_image2/shop_img/870/533/870533704.jpg&quot; /&gt;
	&lt;img src=&quot;http://preview.yes24.com/PreviewResize.aspx?no=33468610&amp;amp;fn=sc5slmx4y8xvdnrc51.jpg&amp;amp;size=531|700&quot; /&gt;
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Swift 3 꼼꼼한 재은씨의 스위프트 3 기본편&lt;/li&gt;
  &lt;li&gt;이것이 iOS다 Swift로 시작하는 iOS 10 앱 개발 입문&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 두 권으로 기본기를 다졌다. 이것이~ 시리즈에서는 간단하게 앱을 만들면서 전반적인 구조를 익히는 느낌이 들었다. 그러다 조금 더 자세한 설명이 필요하다 하여 재은씨 책을 보면서 구조를 공부하였다. 재은씨 책은 정말 무겁고 양이 방대하지만 실제 개발을 하는데 많은 도움이 되었다.&lt;/p&gt;

&lt;h2 id=&quot;기술-스택&quot;&gt;기술 스택&lt;/h2&gt;

&lt;p&gt;기술 스택이라고 할꺼까지 없지만, 추후에 업그레이드 하면서 어떻게 변화되는지가 궁금하여 남기도록 한다.&lt;/p&gt;

&lt;p&gt;우선은 cocoapod에서 사용한 라이브러리들은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod 'Alamofire', '~&amp;gt; 4.0'
pod &quot;GSImageViewerController&quot;
pod 'SDWebImage', '~&amp;gt;3.8'

pod 'Firebase/Core'
pod 'Firebase/Messaging'
pod 'Firebase/Crash'

pod 'SwiftyStoreKit'
pod 'ReachabilitySwift', '~&amp;gt; 3'

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;난관들-정리&quot;&gt;난관들 정리&lt;/h2&gt;

&lt;p&gt;난관이라고 보기 보다, 고민이라고 생각하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;firebase-연동&quot;&gt;Firebase 연동&lt;/h3&gt;

&lt;p&gt;Push 를 사용하기 위해서 FCM과 연동을 하면서 몇 가지 난관이 나에게 왔다. 일단 크게 두 가지로 연동하는 방법과 연동 후 FCM을 통해 메시지를 받은 뒤 핸들러 처리였다.&lt;/p&gt;

&lt;p&gt;1) 연동하는 부분&lt;/p&gt;

&lt;p&gt;이 부분에 대해서 처음에는 어리둥절했었다. Firebase의 예제 코드들이 어디에 위치해야하는지 잘 몰랐지만, 그냥 github repo에 들어가 코드를 보면서 이해하려했다. 물론 코드를 보면서 한 번에 이해하면 좋겠지만 초보자에게는 조금 무리였나보다. 다시 구글링을 통해 iOS Firebase 연동에 대한 글을 보았다.&lt;/p&gt;

&lt;p&gt;고맙게도 누군가 작성해주셨다. &lt;a href=&quot;https://androidtipshare.atlassian.net/wiki/pages/viewpage.action?pageId=46563345&quot;&gt;maroJun님의 게시글&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;친절하게 잘 작성해주셔서 덕분에 연동하는 작업은 잘 끝이 났다.&lt;/p&gt;

&lt;p&gt;2) 완료 핸들러&lt;/p&gt;

&lt;p&gt;사실 이 부분이 가장 고역이었다. 예를 들어 FCM을 통해 Push를 받을 때, 데이터를 받아와서 해당 데이터를 이용해 화면 이동을 어떻게 해야할지 몰랐기에 힘들었다. 여러가지 중에서 하나를 설명하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/***
When get fcm data, set rootviewcontroller that order by Tabbar -&amp;gt; Navaigation -&amp;gt; (Segue) -&amp;gt; view
***/
// AppDelegate.swift
let TabBarViewController : UITabBarController = mainStoryboard.instantiateViewController(withIdentifier: &quot;mainView&quot;) as! UITabBarController

// NavigationController
let infoNavigation = mainStoryboard.instantiateViewController(withIdentifier: &quot;infoNavigation&quot;) as! UINavigationController
let buystockNavigation = mainStoryboard.instantiateViewController(withIdentifier: &quot;buystockNavigation&quot;) as! UINavigationController
let mystockNavigation = mainStoryboard.instantiateViewController(withIdentifier: &quot;mystockNavigation&quot;) as! UINavigationController
let videoNavigation = mainStoryboard.instantiateViewController(withIdentifier: &quot;videoNavigation&quot;) as! UINavigationController
let moreNavigation = mainStoryboard.instantiateViewController(withIdentifier: &quot;moreNavigation&quot;) as! UINavigationController

TabBarViewController.selectedIndex = 2
self.window?.rootViewController = TabBarViewController
TabBarViewController.viewControllers = [infoNavigation,buystockNavigation,mystockNavigation,videoNavigation,moreNavigation]
mystockNavigation.show(detailStockView, sender: self)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;우선 가장 기본적으로 rootview를 생각하면 Tabbar이고 그다음에 navigation, view 이런식으로 쌓일 것이다.&lt;/p&gt;

&lt;p&gt;따라서 rootview를 Tabbar로 하고, 그다음에 root로 설정한 Tabbar에 .viewControllers 라는 것을 보면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;An array of the root view controllers displayed by the tab bar interface.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;루트뷰의 Tabbar 인터페이스를 설정할 수 있게 해준다.(array)
따라서 각각의 navigationcontroller를 array에 담아 넘겨준다.&lt;/p&gt;

&lt;p&gt;그리고 우리가 보여줘야할 view에 해당하는 navigation에서 segue에 해당하는 show를 붙여서 넘겨주면 된다.&lt;/p&gt;

&lt;p&gt;이렇게 화면을 넘겨주면서 동시에 해당 데이터도 넘겨주면 된다.&lt;/p&gt;

&lt;h3 id=&quot;인앱결제&quot;&gt;인앱결제&lt;/h3&gt;

&lt;p&gt;인앱결제를 넣으면서 어떤 프로세스로 구성되는지 몰라서 찾아보았다.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Art/intro_2x.png&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;이 부분을 깔끔?하게 해결 할 수 있는 라이브러리인 SwiftyStoreKit을 사용해서 인앱결제를 구성하였고 영수증 처리도 잘 해결하였다. 처음에는 swift 코드로 작성하려했지만, 도저히 코드상 이해가 되지 않아서 라이브러리를 통해서 쉽게 구매하고 검증하게 하였다.&lt;/p&gt;

&lt;p&gt;나중에 시간이 되면 더 자세히 봐야겠다.&lt;/p&gt;

&lt;h3 id=&quot;리잭reject&quot;&gt;리잭(Reject)&lt;/h3&gt;

&lt;figure&gt;
	&lt;img src=&quot;https://github.com/CodeMath/codemath.github.io/blob/master/assets/img/media/2017-05-01-rejected.jpeg?raw=true&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;심사에 들어가면서 가장 초조했었다. 혹시 이상한 거로 리젝되면 어쩌지… 조금 무서웠다. 역시나 내 예상?대로 새로운 메시지와 함께 Rejected 이라는 단어를 보았다.&lt;/p&gt;

&lt;p&gt;25일부터 차근차근 준비하면서 리젝될 경우의 수를 하나하나 줄여나갔었다. 그리고 29일에 심사를 넣고 기다렸다. 이 심사가 사실 미국시간 기준이라서 조금 걸렸는데, 31일 리뷰를 한다는 메시지를 받은지 1시간 30분 만에 Reject되었다.&lt;/p&gt;

&lt;p&gt;사유를 들어보니, 레이아웃이 문제라고 한다. 분명 아이폰 6S,6S PLUS 사이즈에 대응했었는데… 뭐가 문제일까 자세히 보니 아이패드에서 문제가 발생하였다고 한다.(!)&lt;/p&gt;

&lt;p&gt;분명 타겟 디바이스를 아이폰에서만 하겠다고 했었는데, 왜 아이패드에서 심사를 하는걸까? 라는 생각이 들었는데 아이패드에서도 아이폰 앱을 구동할 수 있다는 사실을 망각했던 것이다. (아이패드에서 아이폰 게임하고 그랬던 것을 까먹었던 것…)&lt;/p&gt;

&lt;p&gt;아이패드 에어2 시뮬레이터로 앱을 빌드해서 확인해보니 레이아웃이 밀려서 버튼이 보이지 않았던 것이다. 아이폰5 부터 아이패드 에어2 시뮬레이터로 하나씩 확인하면서 레이아웃이 밀린 부분이 있는지 체크하면서 수정하였다.&lt;/p&gt;

&lt;p&gt;그리고 다시 심사를 신청하고 (이때가 거의 새벽 5시…) 잠에 들었고 아침에 일어나보니, 심사가 모두 통과해서 앱이 판매가능으로 변경되었다.&lt;/p&gt;

&lt;p&gt;사실 그동안 리젝될 경우의 수를 줄이려고 생각했던 부분에서 가장 기본적인 레이아웃 밀리는 것을 체크하지 못한 내가 멍청했던 것이다.&lt;/p&gt;

&lt;p&gt;우선 내가 체크했던 부분은 다음과 같다. &lt;a href=&quot;http://trend21c.tistory.com/1906&quot;&gt;참고 1&lt;/a&gt; &lt;a href=&quot;http://www.thisisgame.com/webzine/news/nboard/4/?n=61254&quot;&gt;참고 1&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;소셜로그인(카카오톡 로그인)을 사용했기 때문에 별도의 회원가입 대신, 게스트 로그인 기능을 만들었다.&lt;/li&gt;
  &lt;li&gt;스크린샷 부분에서 안드로이드에서 사용했던 이미지 대신 아이폰으로 바꿈&lt;/li&gt;
  &lt;li&gt;최대한 오류가 발생하지 않게 하려고 했다.(당연하잖아?)&lt;/li&gt;
  &lt;li&gt;코인 구매에 대해서 인앱결제 프로세스를 지켰다.(수수료…)&lt;/li&gt;
  &lt;li&gt;타 플랫폼 언급 안함.&lt;/li&gt;
  &lt;li&gt;회원가입 시, 이용약관 및 개인정보 동의 화면에 동의하게 했다.(원래는 없었음)&lt;/li&gt;
  &lt;li&gt;네트워크를 사용하는 부분에 네트워크 표시하기&lt;/li&gt;
  &lt;li&gt;심사에 필요한 정보들 영문화 및 기본 데이터 보여주기(없으면 아무것도 안보이니까)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;등등등 지금 막 생각나는 것들만 적어보았는데, 하필 레이아웃에서 걸렸다는게 아직도 마음이 아프다.&lt;/p&gt;</content><category term="iOS" /><category term="xcode" /><category term="개발" /><category term="정리" /><category term="주파고" /><summary type="html">첫 iOS 앱 개발부터 런칭까지 이야기(1)</summary></entry><entry><title type="html">2017.05 coDematH 개발 로드맵</title><link href="https://codemath.github.io/2017.05-coDematH-%EA%B0%9C%EB%B0%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5/" rel="alternate" type="text/html" title="2017.05 coDematH 개발 로드맵" /><published>2017-05-19T00:00:00+09:00</published><updated>2017-05-19T00:00:00+09:00</updated><id>https://codemath.github.io/2017.05-coDematH-개발-로드맵</id><content type="html" xml:base="https://codemath.github.io/2017.05-coDematH-%EA%B0%9C%EB%B0%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5/">&lt;figure&gt;
	&lt;img src=&quot;https://github.com/CodeMath/codemath.github.io/blob/master/assets/img/media/2017.05-LoadMap.png?raw=true&quot; /&gt;
&lt;/figure&gt;

&lt;hr /&gt;

&lt;p&gt;그동안 개발 공부를 해오며 내가 무엇을 공부했는지에 대해 정리가 부족한 느낌이 들어 이번 기회에 그동안 공부했던 것들을 정리해보려 한다.&lt;/p&gt;

&lt;h2 id=&quot;웹-프로그래밍&quot;&gt;웹 프로그래밍&lt;/h2&gt;
&lt;p&gt;웹 프로그래밍은 ‘멋쟁이 사자처럼’이라는 동아리를 통해서 배웠다. 사실 학교 내 동아리에서 C언어를 공부를 해보았지만 나에게 어울리지 않는 듯 한 느낌이 들었다. 즉, 코딩을 왜? 해야하는가에 대해서 의문이 들었지만 이 질문을 시원하게 답해줄 수 있는 사람들은 아무도 없었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“당신은 왜 코딩을 하십니까?” - 대학교 1학년, 첫 C언어를 접하며&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;웹 프로그래밍을 배 울 당시, 학교 수업에서 메틀랩을 이용해서 알고리즘을 공부하는 수업을 들었다. 그동안의 ‘수학’은 눈에 보이지 않는 것들을 논리와 정의를 통해서 서술하는 것이었다면, 컴퓨터를 이용한 알고리즘 및 계산을 통해  ‘수학’이 눈에 보이기 시작하였다. 이것은 나에게 있어서 첫 번째로 가장 큰 충격적인 사건이었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“눈에 보이지 않는 수학이 아닌, 느낄 수 있는 수학을 하고 싶다.” - 대학교 3학년, 수치해석을 공부하며&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그렇게 내 인생의 두 번 다시 없을 코딩을 시작하게 되었다. ‘멋쟁이 사자처럼’ 동아리에서 처음 배운 언어는 HTML/CSS/Javascript 이다. 사실 배웠다기 보다 공부하는 방법과 방향에 대해서 정확하게 알려준 것이다. 그때 codecademy 사이트에서 스스로 공부하고 또 찾아보며 했던 것이 현재는 습관이 되었다. 그리고 Python 이라는 본격적인 서버사이드 언어를 배웠다.&lt;/p&gt;

&lt;h3 id=&quot;py-파이썬&quot;&gt;Py-파이썬&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Life is short, you need python&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞서 말한 C언어와 다르게 파이썬을 배웠을 때 나는 정말 빠르게 흡수할 수 있었다. 사실 그동안의 내가 했던 공부는 책보고 코딩하고 ‘아하! 그렇구나~’라고 넘어갔었는데, 파이썬을 배우면서 수치해석에 배운 메틀랩 코드를 파이썬으로 구현하는 것을 연습해보았다. 이 과정을 통해서 파이썬을 조금 더 자유롭게 사용할 수 있게 된 것 같다.&lt;/p&gt;

&lt;p&gt;그리고 파이썬을 공부하면서 가장 좋았던 것은 ‘직관적’으로 코드를 해석할 수 있다. 띄어쓰기(Tab)라는 특징 때문에 조금 복잡하게 느껴질 수 도 있지만, 한 눈에 들어오는 코드와 간결함에 매료되었다. 물론 타 언어를 많이 접해보지 못했지만, 나에게 있어서 파이썬은 가장 강력한 무기이다.&lt;/p&gt;

&lt;p&gt;처음에는 Flask를 배웠지만, 후에 스스로 Django로 넘어갔다. (사실 Django-Admin 때문에 넘어간…)
Django를 공부하면서 Python과 Framework 그리고 조금 고급스킬들을 사용할 수 있게 되었다. 물론 100% 전체를 아는 것은 아니기에 아직도 책장에는 Python 기본서와 함께 Django 웹 프로그래밍 책이 있다. 개발에 100%가 어디있겠는가? 까먹으면 다시하고 까먹으면 다시하고 하면서 익숙해지는 과정이 ‘코딩’이기에, 아직도 나는 기본서 및 기타 서적들을 뒤적인다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;물론 Django doc를 더 많이 봤지만 (Django doc 최고)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;jquerybootstrap&quot;&gt;jQuery/Bootstrap&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;하드코딩이냐 라이브러리냐 그것이 문제로다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사실 처음 웹 프로그래밍을 배우면서 힘들었던 적은, ‘모든’ 것들을 하드코딩을 통해 만들어야한다는 점이다. 물론 이 과정이 정말로 중요하다. ‘하드코딩’을 통해 논리적인 연결과 사고의 확장 그리고 더 간결하고 빠르게, 성능향상을 위한 리펙토링을 할 수 있기 때문에(?) 꼭 필요한 과정인 것이다.  jQuery/Bootstrap이라는 것을 배우고 나서 고민을 했었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이렇게 좋은 것들이 있는데, 왜? 하드코딩을 해야하지?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 질문에 대한 답은 그리 멀지 않았다. 예를 들어 Bootrap을 분석해보면 일정 패턴이 존재하였다. 그 패턴을 공부하면서 어떤 방식으로 변형이 가능한지를 알게 된다. 이 과정이 웹 프론트 부분에서 정말 중요하다고 생각한다. 외주를 하다보면 클라이언트 측의 즉각적인 수정사항(?)에 대해서 대응하기 위해서는 하드코딩으로 접근하기 보다는 Bootrap의 일정 패턴을 변형하는 것으로 대응하면, 생각보다 쉽게 해결할 수 있었기 때문이다. (클라이언트의 수정사항이 늘어나지만, 개발기간은 늘어나지 않는다.)&lt;/p&gt;

&lt;h3 id=&quot;web-server&quot;&gt;Web-Server&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;아파치보다는 Nginx&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;일단 오래된 아파치보다는 새로운 것을 사용하고 싶었다. Nginx. 이름 참 멋지지 않은가? Web-Server를 개발하면서 정말 많은 공부를 하게되었다. Nginx와 uwsgi를 묶어주면서 Proxy에 대해서 처음 알게 되었다. Reverse-Proxy를 통해서 사용자의 웹에 보여줄 것들을 랜더링하고, 또 요청을 받아들이고…. 이러한 로직에 대해서 자세히 공부하게 된 것이 바로 Nginx이다. (물론 현재도 참 좋아한다.)&lt;/p&gt;

&lt;h3 id=&quot;mysql&quot;&gt;MySQL&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;easy way, use ORM&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Database는 Flask와 Django 프래임워크를 통해서 ORM으로 처리했다. 덕분에 SQL 구문을 자세히 몰라도 데이터관리가 가능해서 공부하기 쉬웠다. 물론 차후에 SQL구문에 대해서 공부했지만 그 당시 SQL 구문까지 공부했더라면 많이 힘들었을 것 같다. (AWS Lambda를 사용할 때 SQL구문을 자세히 공부했었다.)&lt;/p&gt;

&lt;p&gt;물론 현재는 MySQL만으로 충분하지만 성능적인 면에서 PostgreSQL을 공부해보고 싶다.(비슷하다고 하니…)&lt;/p&gt;

&lt;p&gt;Redis에 관해서는 대략적인 개요는 알지만, 서비스 개발에서 사용해보지는 않았다. (그 정도의 퍼포먼스가 필요하지 않았던지라…)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ios-개발&quot;&gt;iOS 개발&lt;/h2&gt;

&lt;p&gt;사실 내가 가장 해보고 싶었 던 것은 iOS 앱 개발이었다. 파이썬만 배우면 iOS도 개발할 줄 알았다.(멍청이)
웹 프로그래밍을 배울 당시, iOS 앱 개발을 해보고 싶어 찾아보았지만, Object-C라는 언어를 알아야 한다고 하였다. 도서관에서 책을 빌려 조금씩 공부했지만, 쉽지는 않았다. 파이썬 언어에 익숙해진 탓(?)에 객체지향이라는 틀과 Object-C언어의 생소함, Xcode 툴을 다루는 방법, iOS 버전차이 때문에 웹 프로그래밍보다 진입장벽이 나에게 높게 느껴졌다. 하지만 하늘은 나의 편일까? 새로운 언어가 나왔다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Apple의 새로운 언어. Swift&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;swift&quot;&gt;Swift&lt;/h3&gt;

&lt;p&gt;아직도 기억이 난다. Swift 1.0 버전을 처음 공부하면서 파이썬과 비슷한 느낌을 많이 받았다. 함수형 프로그래밍처럼 접근 방식도 편했고, 무엇보다 새로운 언어이기 때문이었다. 물론 언어의 버전이 올라가면서 많은 것이 바뀌고 공식 doc를 분석하기 버거웠기 때문에 조금은 힘들었다. 2.0 버전에 들어서야 본격적으로 iOS 앱 개발을 공부하기 시작하였다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Swift 2.0 버전으로 iOS 8 프로그래밍을 시작.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Swift 2.0 버전에 해당하는 iOS 8 프로그래밍을 공부할 때 쯤, 기본적인 툴을 다룰 수 있었다. 언어적인 측면은 계속 공부하였지만, iOS 프로그래밍을 하는 것에 친숙해져야 한다는 느낌을 받았다. 아무리 언어만 알아도 전체적인 설계와 프로그래밍을 모르면 아무것도 개발할 수 없었기 때문에 iOS 8 프로그래밍 서적의 예제를 3~4번 정도 반복해서 만들어 보았다. 익숙해지면서 스스로 몇가지 앱은 만들 수 있었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;오직 시뮬레이터에서만 가능…하지만 디바이스에서도 디버깅이 된다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;애플은 나의 편인지 참으로 고마웠다. 그동안 시뮬레이터에서만 빌드가 가능했지만, 이제는 디바이스에서도 빌드가 되게끔해주었다. 그러면서 Swift 버전이 올라가고, 파이썬으로 서버를 만들어야 했기 때문에 잠시 쉬었다.
API 서버를 만들면서 꾸준히 Swift 언어가 변경된 사항들을 체크하고 공부하긴 했지만 많이 부족했다. 그리고 Swift 3.0 버전이 나오면서 본격적으로 아이폰 앱 개발을 하게 되었다.&lt;/p&gt;

&lt;h3 id=&quot;cocoapod&quot;&gt;cocoapod&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;앱 개발도 피할 수 없다! 하드코딩이냐 라이브러리냐!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Swift 3.0 버전이 어느 정도 안정화되면서 아이폰 개발이 가능했지만 조금 답답한 느낌이 많이 들었다. Django를 보면 다양한 라이브러리를 통해서 빠르게 개발할 수 있는 장점이 있었는데, iOS 개발은 그런게 없나? 라는 의문이 들었다. 그리고 찾아낸 것이 ‘cocoapod’이다. 코코아팟을 통해 외부 라이브러리를 설치하고 사용할 수 있었다. 처음에 만들었던 코드보다 더욱 간결하고 퍼포먼스도 상승 되었다. 심지어 인앱 결제 부분을 하드코딩해서 만들고 있었지만, 라이브러리를 통해서 정말 쉽고 간편하게 개발할 수 있게 되었다. 물론 가끔 Xcode상의 버그로 잘 안될 때가 있지만, 코코아팟이 참 고맙게 느껴진다.&lt;/p&gt;

&lt;h3 id=&quot;react-native&quot;&gt;React-Native&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Javascript로 모든 것을 만들어볼까요?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;외주를 하면서 가장 고생한 부분은(서버 제외) 자바스크립트이다. 특정 이벤트를 발생시키는 부분을 만들어야했기 때문에 나로써는 자바스크립트로 하드코딩하면서 해야했기 때문이다. 이 자바스크립트를 통해서 iOS 앱을 만들 수 있다는 소식에 React-Native 언어를 찾아보았다. 물론 공부를 시작해야지! 라는 마음을 먹었지만, 쉽게 접근 할 수 없었다. Swift 때 처럼 업데이트도 자주 있었고, 무엇보다 doc만 봐서 어떻게 공부해야할 지 감이 오지 않았다. (지금은 참 잘되었다.) 현재는 iOS는 Swift로만 되어있지만 나중에는 React를 이용해서 만들어 보고 싶다. 퍼포먼스가 잘 나오는 방향으로 서로 접목시켜 개발할 수 있게 해보고 싶다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;dev-ops&quot;&gt;Dev-Ops&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;AWS 최고&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;‘멋쟁이 사자처럼’에서 웹 프로그래밍을 공부할 때는 GAE를 사용하였다. 생각보다 비싼(?) 요금을 유지할 수 없어 결국 AWS로 옮기게 되었다. Azure도 사용해보았지만, Python을 지원이 미비하였고 무엇보다 doc가 부실하여 사용할 수 없었다. 지금 AWS의 프리티어 기간(1년)을 통해서 많은 것 들을 테스트 해볼 수 있었고 무엇보다 프리티어 기간이 끝나도 계속 사용할 수 있는 다양한 서비스들이 있어서 참 좋게 느껴진다.&lt;/p&gt;

&lt;h3 id=&quot;aws&quot;&gt;AWS&lt;/h3&gt;

&lt;p&gt;개발자들의 편의성과 빠른 개발/배포를 가능하게 해준 AWS. 아직도 많이 모르지만, 모르기 때문에 발견하는 재미가 있다. Lambda를 통해서 Serverless한 모바일 서비스를 개발했을 때가 아직도 잊혀지지 않는다. API Gateway를 통해 API를 관리하고 Lambda로 호출하여 함수를 실행시키는 구조인데, 생각보다 쉽다. 물론 기존에 API 서버에서 관리되던 것들을 옮기면서 ‘함수’로 변경해야했지만, Django-RestFramework에서 사용하던 방식을 그대로 이용할 수 있어서 편리했다. (이래서 파이썬을 사용한다?)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lambda를 통해 API 관리와 Cloudwatch 연동까지 그리고 프리티어기간이 끝나도 계속 되는 무료 제공&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;AWS의 S3, EC2, RDS 등등의 서비스들의 유기적 연결성이 개발자들이 서비스를 빠른 시간에 개발할 수 있게 해줌으로써 환경설정 및 시작하는데 오랜 기간을 사용하지 않아도 되서 편리하게 느껴진다.(좋다)&lt;/p&gt;

&lt;h3 id=&quot;docker&quot;&gt;Docker&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;똑똑똑 안녕하세요? Docker 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;처음 Container라는 개념을 잡기가 쉽지 않았다. 기존에 ubuntu 서버에 nginx와 uwsgi 그리고 환경설정 등을 해주었는데, 나중에는 스크립트로 처리했었다. 하지만 Docker를 통해 이미지를 배포한다는 개념이 명확하지 않아 힘들었다. 아직 공부한 부분이 많지 않지만 이번 년도 안에 Docker를 제대로 사용해보고 싶다는 생각이 들었다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;앞으로 무엇을 공부할지를 간략하게 정리해보았다.&lt;/p&gt;

&lt;h3 id=&quot;웹-프로그래밍-1&quot;&gt;웹 프로그래밍&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Django를 기반으로 Nginx와 uwsgi 구조에 대해 더욱 공부해야겠다.&lt;/li&gt;
  &lt;li&gt;TDD에 대해 공부해야겠다.(몇 차례 시작하려 했지만…)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ios-프로그래밍&quot;&gt;iOS 프로그래밍&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Swift와 iOS 프로그래밍 구조에 대해 심도있게 공부해야겠다.(현재는 너무 얕은 느낌이 강하다.)&lt;/li&gt;
  &lt;li&gt;오픈소스 라이브러리를 만들어보고싶다.(희망고문일까?)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dev-ops-1&quot;&gt;Dev-Ops&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Docker 책 샀지만 많이 보지 않았다. 제대로 다시 공부하자.&lt;/li&gt;
  &lt;li&gt;Github와 연계된 다양한 서비스들(Travis 등등)을 사용해보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;과연 몇 가지가 지켜질지 모르지만 일단 해보자.&lt;/p&gt;</content><category term="post" /><category term="develop" /><category term="로드맵" /><category term="정리" /><category term="개발" /><summary type="html">2017년 5월 기준 로드맵 정리</summary></entry><entry><title type="html">[Pyhon] class 구조 이해하기</title><link href="https://codemath.github.io/Pyhon-class-%EA%B5%AC%EC%A1%B0-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[Pyhon] class 구조 이해하기" /><published>2017-05-14T00:00:00+09:00</published><updated>2017-05-14T00:00:00+09:00</updated><id>https://codemath.github.io/[Pyhon]-class-구조-이해하기</id><content type="html" xml:base="https://codemath.github.io/Pyhon-class-%EA%B5%AC%EC%A1%B0-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/">&lt;h2 id=&quot;객체지향-프로그래밍-python---p154&quot;&gt;객체지향 프로그래밍 python - P.154&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;인스턴스화 연산(클래스 확인) -&amp;gt; 빈 객체 생성(함수포함) -&amp;gt; &lt;strong&gt;init&lt;/strong&gt; 가 있다면, 호출해서 새로만든 빈 객체 초기화&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;빈 객체는 self 변수를 추가로 받고 모듈,사전,다른 객체에서처럼 변수에 값 설정
self.tangerine 객체 초기화 &amp;amp; 새로 만든 객체를 받아 thing 변수에 대입&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;</content><category term="python" /><category term="study" /><category term="class" /><category term="post" /><summary type="html">python class instructure</summary></entry><entry><title type="html">[Swift] UIButton Image contentMode code</title><link href="https://codemath.github.io/Swift-UIButton-Image-contentMode-code/" rel="alternate" type="text/html" title="[Swift] UIButton Image contentMode code" /><published>2017-05-14T00:00:00+09:00</published><updated>2017-05-14T00:00:00+09:00</updated><id>https://codemath.github.io/Swift]-UIButton-Image-contentMode-code</id><content type="html" xml:base="https://codemath.github.io/Swift-UIButton-Image-contentMode-code/">&lt;p&gt;Image를 클릭하면 확대하는 View를 만들어주는 &lt;a href=&quot;https://github.com/wxxsw/GSImageViewerController&quot;&gt;라이브러리&lt;/a&gt; 를 사용하던 중, 버튼에 들어간 이미지의 비율이 맞지 않은 경우가 있었다.&lt;/p&gt;

&lt;p&gt;특히나 아이폰 5,6,6S와 같이 비율이 다르기 때문에 이미지 자체를 비율고정값으로 해줘야한다.
이때 해당 버튼의 이미지 비율을 바꾸는 코드는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ImageButton.imageView?.contentMode = .scaleAspectFit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이렇게 해주면 버튼의 이미지 비율을 바꿀 수 있다.&lt;/p&gt;</content><category term="Swift" /><category term="UIButton" /><category term="ios" /><category term="xcode" /><category term="post" /><summary type="html">UIButton Image re-sizing code</summary></entry><entry><title type="html">[Swift]Cocoapods 설치 및 에러 해결</title><link href="https://codemath.github.io/Swift-Cocoapods-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%97%90%EB%9F%AC-%ED%95%B4%EA%B2%B0/" rel="alternate" type="text/html" title="[Swift]Cocoapods 설치 및 에러 해결" /><published>2017-05-08T00:00:00+09:00</published><updated>2017-05-08T00:00:00+09:00</updated><id>https://codemath.github.io/[Swift]Cocoapods-설치-및-에러-해결</id><content type="html" xml:base="https://codemath.github.io/Swift-Cocoapods-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%97%90%EB%9F%AC-%ED%95%B4%EA%B2%B0/">&lt;p&gt;설치 코드는 터미널에서&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gem install cocoapods
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;(오래걸린다.)&lt;/p&gt;

&lt;p&gt;그리고 위 코코아팟을 다 설치하고 나면, 해당 프로젝트 경로로 가서
touch podfile
으로 초기화 파일을 만든다.&lt;/p&gt;

&lt;p&gt;그리고 해당 podFile을 열어서 라이브러리를 설치해준다.&lt;/p&gt;

&lt;p&gt;그런데 간혹 가다가 이상한 에러가 발생한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Pod installation complete! There is 1 dependency from the Podfile and 1 total pod installed.

[!] The `ZuphaGo [Debug]` target overrides the `OTHER_LDFLAGS` build setting defined in 
`Pods/Target Support Files/Pods-ZuphaGo/Pods-ZuphaGo.debug.xcconfig'. 
This can lead to problems with the CocoaPods installation 
- Use the `$(inherited)` flag, or 
- Remove the build settings from the target.

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;무슨 말인지 설명하면, 코코아팟을 이용해서 라이브러리를 오버라이드할 때 환결 설정이 문제가 된 것이다.
따라서 저 말에 따른 해결방법으로&lt;/p&gt;

&lt;p&gt;(1) 프로젝트/타겟 → Build Settings에서 “ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES”를 검색
그리고 디벅그와 릴리스 둘 다, “$(inherited)”를 추가해준다.&lt;/p&gt;

&lt;p&gt;그래도 해결이 안될 것이다.&lt;/p&gt;

&lt;p&gt;두번째로 해결해야하는 부분이&lt;/p&gt;

&lt;p&gt;(2) Build Settings에서 Other Linker Flags에 들어간다. 그리고 기존에 -ObjC로 되어있는  부분을 삭제 한다.&lt;/p&gt;

&lt;p&gt;그러면 pod으로 프레임워크 라이브러리는 설치가 된 것이다.&lt;/p&gt;

&lt;p&gt;하지만 여기서 문제, 설치가 되었다고 다 열리는게 아니란다….
즉, 해당 모듈을 가져올 수 없다는 어처구니없는 오류가 나온다.&lt;/p&gt;

&lt;p&gt;우리가 설치한 프레임워크를 따로 추가해줘야한다. (귀찮)&lt;/p&gt;

&lt;p&gt;(1) Build Phases 에서  Link Binary With Libraries 에 해당 프레임워크를 추가한다. (여기서 기존의 ###.xcodeproj 로 하면 안될 수 있으니 추가로 만들어진 ###.xcworkspace 파일을 열어 추가한다.&lt;/p&gt;

&lt;p&gt;(2) 그리고 혹시나…. 해서 하는데, 만약 추가해도 에러 표시가 난다면 한 번 빌드를 해주자. 그러면 아무런 문제가 없을 것이다~&lt;/p&gt;</content><category term="Swift" /><category term="cocoapods" /><category term="ios" /><category term="xcode" /><category term="post" /><summary type="html">Cocopods 설치 및 에러 해결</summary></entry><entry><title type="html">[Review]Serverless AWS Lambda VS Django-RestFramework</title><link href="https://codemath.github.io/Review-Serverless-AWS-Lambda-VS-Django-RestFramework/" rel="alternate" type="text/html" title="[Review]Serverless AWS Lambda VS Django-RestFramework" /><published>2017-05-08T00:00:00+09:00</published><updated>2017-05-08T00:00:00+09:00</updated><id>https://codemath.github.io/[Review]Serverless-AWS-Lambda-VS-Django-RestFramework</id><content type="html" xml:base="https://codemath.github.io/Review-Serverless-AWS-Lambda-VS-Django-RestFramework/">&lt;p&gt;새로운 테스팅 앱을 만들기 위해서 서버를 만들어야 했다.
사실 매번 EC2를 만들면서 환경설정을 직접 명령어로 쳐줘야했었다. 물론 도커로 그냥 필요할 떄마다 이미 저장된 컨테이너를 불러와도 되지만,
여전히 나에겐 귀찮은 존재…. “서버”&lt;/p&gt;

&lt;p&gt;마침 “유행”?인듯 아닌 듯 “Serverless”라는 것이 화두되었고, 어짜피 테스팅 앱으로 만들 서버를 이번 기회에 Serverless하게 바꿔보기로 했다.&lt;/p&gt;

&lt;p&gt;[ 참고사항 : Python 2.7 / 각 코드 및 설정마다 오류가 있을 수 있습니다. 단순히 테스팅 목적을 위한 서버라… ]&lt;/p&gt;

&lt;p&gt;여튼 기존에 로컬에서 DRF로 만든 API를 함수형태로 바꿔서 정리하였다.&lt;/p&gt;

&lt;p&gt;막상 doc를 보면서 코드를 올리고 테스트해보려 한 순간…. 라이브러리 문제다. 제대로 import 할 수 없다고 한다….
(…. 경로….) 파이참을 사용하고 있던 터라 가상환경의 라이브러리를 제대로 import 못한 것이다. (여기서 1차멘붕)&lt;/p&gt;

&lt;p&gt;가상환경에 설치한 몇몇의 라이브러리들을 꺼내와 파이썬 파일과 합쳐서 업로드 하고 테스트하였다.&lt;/p&gt;

&lt;p&gt;(get 이나 그냥 print 로 return 하는 부분은 쉬우니 넘어가도록 함.)
사실 상 2차 멘붕이 오기시작한 부분은 “RDS”에서 데이터를 가져오기 위해서는 ‘쿼리문’을 작성해야한다는 것이다. (오우쉣)&lt;/p&gt;

&lt;p&gt;그동안  Django에서 얼마나 쉽게 데이터를 가져왔나? ㅠㅠ&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Django
User.objects.all()
Device.objects.filter(uuid= Is_uuid)

#mySQL
&quot;select * from auth_user&quot;
&quot;select * from Device where uuid='%s'&quot; %(Is_uuid)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;그나마 파이썬으로 쿼리문 작성하니 그나마….그나마 편하지만, 그래도 어~~엄청 불편했다. (그러게 mysql 공부하기 싫다고 땡깡부리지 말랬지?ㅠ)&lt;/p&gt;

&lt;p&gt;그래도 그나마 RDS 연결 관련해서는 AWS 문서에 예제로 잘 나와있다. (고마워요~)&lt;/p&gt;

&lt;p&gt;함수 파일말고 라이브러리 처럼 import하는 방식으로 rds 정보를 입력해두고서, 메인 파일에서 불러와 사용한다.
예를 들어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import sys
import logging
import rds_config

#rds settings
rds_host  = &quot;mysql-rds-host&quot;
name = rds_config.db_username
password = rds_config.db_password
db_name = rds_config.db_name


logger = logging.getLogger()
logger.setLevel(logging.INFO)

try:
    conn = pymysql.connect(rds_host, user=name, passwd=password, db=db_name, connect_timeout=5, charset=&quot;utf8&quot;, use_unicode=True)
except:
    logger.error(&quot;ERROR: Unexpected error: Could not connect to MySql instance.&quot;)
    sys.exit()

logger.info(&quot;SUCCESS: Connection to RDS mysql instance succeeded&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이런식으로 코드를 먼저 돌리고 hadler처리를 하면 된다. (쉽당)&lt;/p&gt;

&lt;p&gt;클라우드 왓치와 함께 로그를 저장하고 모니터링할 수 있어서 왠걸…. 걍…. 이지하다.&lt;/p&gt;

&lt;p&gt;사실 좀 멘붕은 아니고 당황스러웠던 점은, Django에서는 Httpresponse로 json을 dumps시켜서 넘겨줬었는데 여기서는 그냥 dict 형태로 던져도 알아서 json으로 읽어올 수 있었다. (왜지?왜지?왜지?왜지?)
(사실,  response body에서 나오는 부분의 컨텐츠 타입을 API Gateway에서 json으로 처리해버린다는 것을 보기전까지만 해도 이해가 되지 않았다….ㅠ)&lt;/p&gt;

&lt;p&gt;여튼 그냥 dict로 넘겨버릴 수 있다니…. python 사용자 입장에서는 정말 말 그대로 개이득이다.&lt;/p&gt;

&lt;p&gt;테스팅으로 돌렸을 때,&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;https://github.com/CodeMath/codemath.github.io/blob/master/assets/img/media/2018-05-08-%5BReview%5DServerless-AWS-Lambda-VS-Django-RestFramework-img-1.png?raw=true&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;음… 그렇다. 가장 적은 메모리로 설정하고 돌렸더니, 122.73.ms가 나온다. (lambda test)
그렇기 때문에 빌링은 200ms로 산정된다. (나쁜놈들 ㅠ 무조건 올리냐….쪼금만 바주….라…) ㅠㅠ&lt;/p&gt;

&lt;p&gt;여튼 1차 테스트에서는 이정도 속도가 나오긴한다.&lt;/p&gt;

&lt;p&gt;그리고 API Gateway에 물려서 API로 만들어 준다. (자세한 방법은 다음에….)&lt;/p&gt;

&lt;p&gt;그리고 Rest client 앱으로 테스트 해봤다.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;https://github.com/CodeMath/codemath.github.io/blob/master/assets/img/media/2018-05-08-%5BReview%5DServerless-AWS-Lambda-VS-Django-RestFramework-img-2.png?raw=true&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;으악…. 속도가 늘었다…. 분명 Lambda에서는 122였는데….  아마도 캐싱이 안된 데이터를 가져오다 보니 그런 듯 하다.
(실제 동일한 주소로 데이터를 불러오니 속도가 53ms로 확 줄었다.)&lt;/p&gt;

&lt;p&gt;아마도 최종 빌링 값은 100 또는 200 (캐싱안되 있다면….300)으로 나올 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;현재 AWS 프리티어로 Lambda를 사용할 경우, 가장 적은 메모리(128)을 사용하면 320만 ms를 무료로 사용할 수 있다. (물론 프리티어 끝나고도 쭈욱 이어진다고 한다.)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AWS Lambda를 사용하면서 느낀 강점은 각 API를 잘게 쪼개 하나의 핸들러로 관리할 수 있다는 장점이다. (이게 어마어마 하게 편하다.)
각 기능이나 추가되는 부분에 대해서 핸들러의 연결성이 낮아져 관리와 업데이트가 참 용이하다는 것을 느꼈다.(으앙 지리뮤)&lt;/p&gt;

&lt;p&gt;그동안 DRF를 이용하면서 Swagger를 만들고 테스팅하게끔하는 부분이 정말 귀찮을 만큼?! 짜증이 나긴했었는데…. 이건 뭐 엄청 편해졌다.
(사실 그동안 주의깊게 안봐서 그렇지 API Gateway도 진짜좋다….ㅎ)&lt;/p&gt;</content><category term="aws" /><category term="serverless" /><category term="server" /><category term="lambda" /><category term="review" /><category term="post" /><summary type="html">[Review]Serverless AWS Lambda VS Django-RestFramework</summary></entry><entry><title type="html">[Django] custom admin page settings</title><link href="https://codemath.github.io/Django-custom-admin-page-settings/" rel="alternate" type="text/html" title="[Django] custom admin page settings" /><published>2017-05-08T00:00:00+09:00</published><updated>2017-05-08T00:00:00+09:00</updated><id>https://codemath.github.io/[Django]-custom admin-page settings</id><content type="html" xml:base="https://codemath.github.io/Django-custom-admin-page-settings/">&lt;center&gt;#Django - custom admin page settings&lt;/center&gt;

&lt;p&gt;Django에서 custom으로 admin페이지를 설정하기 위해서는 아주 간단하다.&lt;/p&gt;

&lt;p&gt;우선  settings.py에서 다음과 같은 코드와 설정을 추가하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...

INSTALLED_APPS = [
...
'django.contrib.admin',
...
]
...
TEMPLATES = [
    {
        ...
           'DIRS': [os.path.join(BASE_DIR, 'templates')],

        ...
    }
]

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;여기서 주의해야한다. 즉, 우리가 수정할 django admin에 해당하는 html파일을 복사해서 수정을 해도 계속 예전것으로 나오는 문제가 생길 것이다. 구글링해서 찾긴했다. (http://stackoverflow.com/questions/25727687/django-1-7-updating-base-site-html-not-working)
짜증나는게 계속 바뀌지 않는 것.&lt;/p&gt;

&lt;p&gt;그 이유를 들여다 보면, 우리가 custom admin html을 수정환 application이 settings.py의 INSTALLED_APPS 리스트에서 뒤쪽에 나와서 적용이 안되는 것이다. 즉, admin html을 사용할 놈이 django.contrib.admin 이 놈부터 적용되서 그런 것 이다.
따라서 맨 뒤로~ 맨 뒤로~ 보내주면 우리가 커스텀한 놈이 나온다!&lt;/p&gt;</content><category term="python" /><category term="django" /><category term="custom" /><category term="admin" /><category term="settings" /><category term="post" /><summary type="html">How to DJango's custom admin settings</summary></entry></feed>
